<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><docs>https://blogs.law.harvard.edu/tech/rss</docs><title>python on Bryan Apperson</title><link>https://bryanapperson.com/tags/python/</link><description>Recent content in python on Bryan Apperson</description><image><title>python on Bryan Apperson</title><link>https://bryanapperson.com/tags/python/</link><url>https://source.unsplash.com/collection/983219/2000x1322</url></image><ttl>1440</ttl><generator>Hugo 0.81.0</generator><language>en-US</language><copyright>Copyright &amp;copy; Bryan Apperson. Licensed under CC-BY-ND-4.0. Hosted on Github.</copyright><lastBuildDate>Fri, 19 Mar 2021 02:52:51 UT</lastBuildDate><atom:link href="https://bryanapperson.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>A Gradual Journey to Typed Python</title><link>https://bryanapperson.com/blog/gradually-typed-python/</link><pubDate>Thu, 18 Mar 2021 22:14:00 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/gradually-typed-python/</guid><description>Python is much loved by developers for its ease of development, its low time to minimum viable product and, some might say, its dynamic typing. I&amp;rsquo;ve been using dynamically typed Python for the better part of a decade now, for those same reasons. Dynamically typed Python is rapid to develop in, features amorphous blobs of data and works great for writing code quickly.
Gradual typing and static analysis split the difference between the reduced velocity of a strongly typed language and the likewise reduced velocity of maintaining code where the input and output data types are unclear.</description><content:encoded>Python is much loved by developers for its ease of development, its low time to minimum viable product and, some might say, its dynamic typing. I&amp;amp;rsquo;ve been using dynamically typed Python for the better part of a decade now, for those same reasons. Dynamically typed Python is rapid to develop in, features amorphous blobs of data and works great for writing code quickly.
Gradual typing and static analysis split the difference between the reduced velocity of a strongly typed language and the likewise reduced velocity of maintaining code where the input and output data types are unclear. Gradually typed Python makes reasoning about larger, and older, codebases easier. When I started using types in Python, I was just sprinkling in type annotations here and there. The Python type hinting system can do much more.
Static Analysis of Gradually Typed Python Formatting tools like Black and isort, along with static analysis tools like Flake8 are great for keeping python code consistent in form and free of unused variables. But Python type hinting can do more. Mypy provides many of the compile time checks you&amp;amp;rsquo;d get in a strongly typed, compiled language like Rust, which are useful when developing and add no overhead at runtime.
Command Line Interfaces via Typed Python Click is one of my favorite command line interface libraries. Recently I stumbled upon Typer, Typer is an abstraction on top of Click which uses type annotations and doctrings to generate beautiful command line interfaces with much less boilerplate code. Using Typer, a command line interface is easy to build in just a few lines.
De/Serialization and Validation with Types Pydantic, especially when combined with mypy is a sure fire way to get lightning fast data models with low cost of development, and lower probability of bugs for serialization, deserizaliztion, and by nature, data validation.
Conclusion Using the type hinting system has made my code better, made me a better developer, and allowed the sort of semantics used in languages like Rust in Python. I think it can do the same for the reader, and is definitely worth using. I hope to put out some more blogs in the near future on my Python toolbox and maybe even a sample app putting it all together.</content:encoded></item><item><title>Copy Ceph Pool Objects to Another Pool</title><link>https://bryanapperson.com/blog/copy-ceph-pool-objects-to-another-pool/</link><pubDate>Tue, 17 Nov 2015 23:06:18 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/copy-ceph-pool-objects-to-another-pool/</guid><description>Sometimes it is necessary to copy Ceph pool objects from one Ceph pool to another - such as when changing CRUSH/erasure rule sets on an expanding cluster. There is a built-in command in RADOS for doing this. However the command in question, rados cppool , has some limitations. It only seems to work with replicated target pools. Thus it cannot copy Ceph pool objects from a erasure pool to a replicated pool, or between erasure pools.</description><content:encoded><![CDATA[Sometimes it is necessary to copy Ceph pool objects from one Ceph pool to another - such as when changing CRUSH/erasure rule sets on an expanding cluster. There is a built-in command in RADOS for doing this. However the command in question, rados cppool , has some limitations. It only seems to work with replicated target pools. Thus it cannot copy Ceph pool objects from a erasure pool to a replicated pool, or between erasure pools. So to offer a utility for copying the contents of an erasure coded pool to another erasure pool, this evening I wrote up a function in my python-rados-utils repository. To use the python-rados-utils package, you first have to build and install it. At this point the repository only works with RHEL/CentOS/Fedora due to the RPM based build system. You can however look through the code for usage on other platforms. It&amp;rsquo;s pretty easy to get python-rados-utils up and running. Building from python-rados-utils from source:
git clone git@github.com:bryanapperson/python-rados-utils.git cd python-rados-utils rpmbuild -ba python-rados-utils.spec Installing python-rados-utils: The rpm from the build we just did will be output in ~/rpmbuild/RPMS/noarch/. Install the rpm using: rpm -Uvh &amp;lt;path-to-rpm&amp;gt; Once the python-rados-utils package is installed, using it to copy all objects from one Ceph pool to another is very straight-forward. In your favorite text editor, open up a file called copy_objects.py . In this file place:
# Optionally you can pass in the keyring and ceph.conf # locations as strings. thiscluster = common_utils.Cluster() # Replace these empty stings with your source and target pool names source = &amp;#39;&amp;#39; target = &amp;#39;&amp;#39; thiscluster.copy_pool(source, target) NOTE: Updated versions of the above snippet can be found here. This script is single threaded at the moment and synchronous. I may add asynchronous and multi-threading functionalities to speed up Ceph pool copy in the near future. This code comes with no warranty of any kind and the code is licensed under GPLv2. Test in your own environment, but for me this worked well to copy all objects in one pool to another. Please leave your thoughts in the comments below and commit back any cool stuff to the python-rados-utils repository.
]]></content:encoded></item></channel></rss>