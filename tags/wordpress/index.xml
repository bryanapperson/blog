<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><docs>https://blogs.law.harvard.edu/tech/rss</docs><title>wordpress on Bryan Apperson</title><link>https://bryanapperson.com/tags/wordpress/</link><description>Recent content in wordpress on Bryan Apperson</description><image><title>wordpress on Bryan Apperson</title><link>https://bryanapperson.com/tags/wordpress/</link><url>https://source.unsplash.com/collection/983219/2000x1322</url></image><ttl>1440</ttl><generator>Hugo 0.81.0</generator><language>en-US</language><copyright>Copyright &amp;copy; Bryan Apperson. Licensed under CC-BY-ND-4.0. Hosted on Github.</copyright><lastBuildDate>Thu, 20 May 2021 20:40:03 UT</lastBuildDate><atom:link href="https://bryanapperson.com/tags/wordpress/index.xml" rel="self" type="application/rss+xml"/><item><title>Installing WordPress with Nginx on Ubuntu 14.04</title><link>https://bryanapperson.com/blog/installing-wordpress-with-nginx-on-ubuntu-14-04/</link><pubDate>Mon, 17 Feb 2020 23:10:08 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/installing-wordpress-with-nginx-on-ubuntu-14-04/</guid><description>Installing WordPress with Nginx on Ubuntu 14.04 is a fairly straightforward task. In this tutorial we will do over how to do it. This tutorial assumes you have completed the Getting Started with an Ubuntu VPS guide and have an Ubuntu 14.04 VPS (if not you can get one at vultr). It also assumes that you already have a LEMP stack setup (Linux, Nginx, MySQL, etcetera) or you are following the WordPress HHVM guide.</description><content:encoded><![CDATA[Installing WordPress with Nginx on Ubuntu 14.04 is a fairly straightforward task. In this tutorial we will do over how to do it. This tutorial assumes you have completed the Getting Started with an Ubuntu VPS guide and have an Ubuntu 14.04 VPS (if not you can get one at vultr). It also assumes that you already have a LEMP stack setup (Linux, Nginx, MySQL, etcetera) or you are following the WordPress HHVM guide. This tutorial assumes the use of Nginx as the web server, Fastcgi or HHVM for PHP and either MariaDB or MySQL for your MySQL server. The first step in this tutorial is to connect to your virtual machine via SSH. This tutorial assumes that you are using Linux as your operating system and have SSH installed. If you do not you can use a tool like Putty for SSH. In Linux you just need to run the following command:
ssh -p port user@you.rip.add.res After connecting to your instance via SSH it is time to begin the process of installing WordPress to work with Nginx. All of our tutorials for Nginx assume a &amp;ldquo;web root&amp;rdquo; of /var/www/html, make sure that your Nginx configuration points there and that the directory exists. If the directory does not exist create it using mkdir and chown it to www-data .
sudo mkdir /var/www/ sudo mkdir /var/www/html/ sudo chown -R www-data:www-data /var/www/html/ Creating a Database and User After you have confirmed that Nginx is using /var/www/html/ as your web root or setup another of your choice, it&amp;rsquo;s time to create a database for WordPress. Please make sure you have already setup MySQL or MariaDB prior to this step. Setting up the database is easy. Start by logging into an interactive session with the MySQL administrative account.
mysql -u root -p You will be prompted for the root password you setup during MySQL installation. Enter it and proceed to the interactive prompt. Next we are going to create a database for WordPress to use and store information in. The name of the database does not matter, but it should be memorable so that you can distinguish it as you add additional databases later on. To do this simply run this command:
CREATE DATABASE wordpress; Note the semi-colon (;) that ends the MySQL statement. Every MySQL statement must end with one, so check that if you are running into issues. Now that you have created a database, we need to create a user. You are going to use the same interactive interface you are in now to create a user. Use this command:
CREATE USER wordpressuser@localhost IDENTIFIED BY &#39;password&#39;; Make sure you replace &amp;lsquo;password&amp;rsquo; with the database password you want to use and &amp;lsquo;wordpressuser&amp;rsquo; with the name of the database user you want to create. After that is done you need to assign that user privileges to use the database we just created. Use this command:
GRANT ALL PRIVILEGES ON wordpress.\* TO wordpressuser@localhost; Make sure you replace the database name and username with the ones you created. Everything should now be configured correctly. We need to flush the privileges (save them to disk) so that our current instance of MySQL knows about the privilege changes we have made:
FLUSH PRIVILEGES; Now you can exit MySQL:
exit
At this point you are back at the shell command prompt and ready to continue.
Installing WordPress with Nginx on Ubuntu 14.04 The next step is to download the latest version of WordPress to the server. It is available on their website. We are going to use the wget command to copy it to our home directory. WordPress always keeps the latest stable version at the place we will use in this command.
cd ~ wget http://wordpress.org/latest.tar.gz The files which compose WordPress were downloaded as a compressed archive stored in a file called latest.tar.gz. We can extract the contents by typing:
tar xzvf latest.tar.gz This will extract a directory called wordpress containing all the files we need to set up WordPress. First however make sure that php5-gd and libssh2-php are installed. If they are not, run the command below. This will make sure you can work with images and install modules/plugins over SSH.
sudo apt-get update sudo apt-get install php5-gd libssh2-php Configuring WordPress with Nginx on Ubuntu 14.04 Now we are ready to configure WordPress and move it into the web root. Let&amp;rsquo;s move into the directory that we extracted WordPress to in the last section:
cd ~/wordpress Now we want to copy the sample configuration to take the place of the non-existent main configuration.
cp wp-config-sample.php wp-config.php
Next we need to make 3 small changes to wp-config.php using nano or your text editor of choice.
nano wp-config.php
The file is suitable for launching WordPress; it is just lacking the information to connect to the database we created a few minutes ago. The parameters we need to set are DB_NAME , DB_USER , and DB_PASSWORD . After you make the changes to that section of the file it should look something like this:
// ** MySQL settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define(&#39;DB_NAME&#39;, &#39;wordpress&#39;); /** MySQL database username */ define(&#39;DB_USER&#39;, &#39;wordpressuser&#39;); /** MySQL database password */ define(&#39;DB_PASSWORD&#39;, &#39;password&#39;); For now you can ignore the rest of the site. If you are planning on deploying a multisite network add this line:
/* Multisite */ define( &amp;lsquo;WP_ALLOW_MULTISITE&amp;rsquo;, true );
Once you have made these changes you can save and close the file. Now it is time to copy the files to our web root (/var/www/html/ in this example). We can copy the files to this place by typing:
sudo rsync -avP ~/wordpress/ /var/www/html/ Now we need to move over to that folder to assign some permissions.
cd /var/www/html/ Then we are going to make sure that Nginx owns these files so that it can manipulate them.
sudo chown -R www-data:www-data /var/www/html/*
Before we move on, we should create a new directory for user uploads:
mkdir wp-content/uploads The new directory should have group writing set already, but the new directory isn&amp;rsquo;t assigned with www-data group ownership yet. Let&amp;rsquo;s fix that:
sudo chown -R :www-data /var/www/html/wp-content/uploads Now just make sure that your web server is configured to use /var/www/html/ as the webroot and you can visit yourdomain.com to set your site name and get started. You are also going to want to install Postfix so that WordPress can send emails. We will be writing a tutorial for that in the near future. Thanks for reading and leave your thoughts in the comments below.
]]></content:encoded></item><item><title>Configure Nginx/HHVM for WP - Making WordPress Fly</title><link>https://bryanapperson.com/blog/configure-nginx-hhvm-for-wp-making-wordpress-fly/</link><pubDate>Mon, 17 Feb 2020 20:40:54 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/configure-nginx-hhvm-for-wp-making-wordpress-fly/</guid><description>The next step in the tutorial &amp;ldquo;Making WordPress Fly&amp;rdquo; is to configure Nginx/HHVM and install WordPress. This step has two options, configuring for single site (this article) or configuring for multisite. This tutorial will assume that you have completed the prerequisites and read the introduction (part one). It will also that you have completed both parts two and three. We will also assume that you have an Ubuntu VPS. If you don&amp;rsquo;t, you can get one at Vultr.</description><content:encoded><![CDATA[The next step in the tutorial &amp;ldquo;Making WordPress Fly&amp;rdquo; is to configure Nginx/HHVM and install WordPress. This step has two options, configuring for single site (this article) or configuring for multisite. This tutorial will assume that you have completed the prerequisites and read the introduction (part one). It will also that you have completed both parts two and three. We will also assume that you have an Ubuntu VPS. If you don&amp;rsquo;t, you can get one at Vultr. At this point you should have your VPS secured. You should also have MariaDB, Nginx, and HHVM installed. The first step in this section is to reconnect to your VM via SSH.
ssh -p port user@you.rip.add.res
After connecting to your instance, we are going to create a location to install WordPress. We are going to use /var/www/html however you can use a different directory like /var/www/html/domain-com/ if you choose to. Be aware that you will have to update the configurations to match if you choose a different directory structure. Creating the new directory is straightforward.
sudo mkdir /var/www/html/
We need to install WordPress to /var/www/html . The guide for that can be found here. Once you have completed that, you are ready to move on to the next step. Configuring Nginx for Multisite WordPress with W3 Total cache is the most involved part of the &amp;ldquo;Making WordPress Fly&amp;rdquo; series. At this point we are going to assume that you have been following the series since the beginning. We are also going to assume you already have an Ubuntu VPS. So far we have secured an Ubuntu VPS, setup MariaDB, installed HHVM and installed Nginx. Now we are ready for part 4a, to configure Nginx to work with WordPress Multisite and W3 Total Cache. Part 4b is the alternative if you only need a single site WordPress install on your HHVM enhanced, WordPress optimized VPS. Choosing a multisite install definitely makes sense as you can use this VPS to host more then a few sites, even if the get significant traffic.
That&amp;rsquo;s all for now.
]]></content:encoded></item><item><title>MariaDB 10.1 Setup for Ubuntu 14.04 - Make WordPress Fly</title><link>https://bryanapperson.com/blog/mariadb-10-1-setup-for-ubuntu-14-04-make-wordpress-fly/</link><pubDate>Mon, 17 Feb 2020 20:35:53 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/mariadb-10-1-setup-for-ubuntu-14-04-make-wordpress-fly/</guid><description>In this tutorial we will cover optimal MariaDB 10.1 setup for Ubuntu 14.04 on a VM with 2-4GB of RAM. This is part 2 of the &amp;ldquo;Make WordPress Fly&amp;rdquo; tutorial. You can find part 1 here. Part 1 covered the benefits of using HHVM, MariaDB, Nginx and Ubuntu 14.04 to run a WordPress website. In this section we&amp;rsquo;ll be digging in to MariaDB and the optimal configurations for it. This tutorial assumes you have a VM with at least 512MB of RAM, 1 Xeon Core, 10 GB HDD and Vanilla Ubuntu 14.</description><content:encoded><![CDATA[In this tutorial we will cover optimal MariaDB 10.1 setup for Ubuntu 14.04 on a VM with 2-4GB of RAM. This is part 2 of the &amp;ldquo;Make WordPress Fly&amp;rdquo; tutorial. You can find part 1 here. Part 1 covered the benefits of using HHVM, MariaDB, Nginx and Ubuntu 14.04 to run a WordPress website. In this section we&amp;rsquo;ll be digging in to MariaDB and the optimal configurations for it. This tutorial assumes you have a VM with at least 512MB of RAM, 1 Xeon Core, 10 GB HDD and Vanilla Ubuntu 14.04 installed and ideally secured. So, assuming you have your Ubuntu VPS all setup, we will proceed with the fairly straightforward process of installing MariaDB on Ubuntu 14.04. We are specifically going to be deploying MariaDB 10.1 which as discussed in part 1 has significant performance benefits over even the newest versions on MySQL. First, connect to your VM via SSH.
ssh -p port user@you.rip.add.res
Then we&amp;rsquo;ll add the MariaDB 10.1 repository and install the prerequisites.
sudo apt-get install software-properties-common sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db sudo add-apt-repository &#39;deb http://ftp.osuosl.org/pub/mariadb/repo/10.1/ubuntu trusty main&#39; Once the key is imported and the repository added we will install MariaDB.
sudo apt-get update sudo apt-get install mariadb-server During that process you will be prompted to create a root password for MariaDB. Make sure that you store it in a safe place. Consider using KeePass (or a similar utility) for test passwords, it creates strong passwords you can review later and encrypts them with a master key. Now that MariaDB is installed we need to make sure it runs on startup.
sudo update-rc.d mysql defaults Then, run the sudo mysql_secure_installation. This will guide you through some procedures that will remove some defaults which are dangerous to use in a production environment.
Next we will want to check that everything looks good in the my.cnf file.
nano /etc/mysql/my.cnf It looks like this, yours should be similar, it may be a bit different as MariaDB does some system based configuration on installation.
socket	= /var/run/mysqld/mysqld.sock nice	= 0 [mysqld] # # * Basic Settings # user	= mysql pid-file	= /var/run/mysqld/mysqld.pid socket	= /var/run/mysqld/mysqld.sock port	= 3306 basedir	= /usr datadir	= /var/lib/mysql tmpdir	= /tmp lc_messages_dir	= /usr/share/mysql lc_messages	= en_US skip-external-locking # # Instead of skip-networking the default is now to listen only on # localhost which is more compatible and is not less secure. bind-address	= 127.0.0.1 # # * Fine Tuning # max_connections	= 100 connect_timeout	= 5 wait_timeout	= 600 max_allowed_packet	= 16M thread_cache_size = 128 sort_buffer_size	= 4M bulk_insert_buffer_size	= 16M tmp_table_size	= 32M max_heap_table_size	= 32M # # * MyISAM # # This replaces the startup script and checks MyISAM tables if needed # the first time they are touched. On error, make copy and try a repair. myisam_recover = BACKUP key_buffer_size	= 128M #open-files-limit	= 2000 table_open_cache	= 400 myisam_sort_buffer_size	= 512M concurrent_insert	= 2 read_buffer_size	= 2M read_rnd_buffer_size	= 1M # # * Query Cache Configuration # # Cache only tiny result sets, so we can fit more in the query cache. query_cache_limit	= 128K query_cache_size	= 64M # for more write intensive setups, set to DEMAND or OFF #query_cache_type	= DEMAND # # * Logging and Replication # # Both location gets rotated by the cronjob. # Be aware that this log type is a performance killer. # As of 5.1 you can enable the log at runtime! #general_log_file = /var/log/mysql/mysql.log #general_log = 1 # # Error logging goes to syslog due to /etc/mysql/conf.d/mysqld_safe_syslog.cnf. # # we do want to know about network errors and such log_warnings	= 2 # # Enable the slow query log to see queries with especially long duration #slow_query_log[={0|1}] slow_query_log_file	= /var/log/mysql/mariadb-slow.log long_query_time = 10 #log_slow_rate_limit	= 1000 log_slow_verbosity	= query_plan #log-queries-not-using-indexes #log_slow_admin_statements # # The following can be used as easy to replay backup logs or for replication. # note: if you are setting up a replication slave, see README.Debian about # other settings you may need to change. #server-id	= 1 #report_host	= master1 #auto_increment_increment = 2 #auto_increment_offset	= 1 log_bin	= /var/log/mysql/mariadb-bin log_bin_index	= /var/log/mysql/mariadb-bin.index # not fab for performance, but safer #sync_binlog	= 1 expire_logs_days	= 10 max_binlog_size = 100M # slaves #relay_log	= /var/log/mysql/relay-bin #relay_log_index	= /var/log/mysql/relay-bin.index #relay_log_info_file	= /var/log/mysql/relay-bin.info #log_slave_updates #read_only # # If applications support it, this stricter sql_mode prevents some # mistakes like inserting invalid dates etc. #sql_mode	= NO_ENGINE_SUBSTITUTION,TRADITIONAL # # * InnoDB # # InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/. # Read the manual for more InnoDB related options. There are many! default_storage_engine	= InnoDB # you can&amp;#39;t just change log file size, requires special procedure #innodb_log_file_size	= 50M innodb_buffer_pool_size	= 256M innodb_log_buffer_size	= 8M innodb_file_per_table	= 1 innodb_open_files	= 400 innodb_io_capacity	= 400 innodb_flush_method	= O_DIRECT # # * Security Features # # Read the manual, too, if you want chroot! # chroot = /var/lib/mysql/ # # For generating SSL certificates I recommend the OpenSSL GUI &amp;#34;tinyca&amp;#34;. # # ssl-ca=/etc/mysql/cacert.pem # ssl-cert=/etc/mysql/server-cert.pem # ssl-key=/etc/mysql/server-key.pem [mysqldump] quick quote-names max_allowed_packet	= 16M [mysql] #no-auto-rehash	# faster start of mysql but no tab completition [isamchk] key_buffer	= 16M # # * IMPORTANT: Additional settings that can override those from this file! # The files must end with &amp;#39;.cnf&amp;#39;, otherwise they&amp;#39;ll be ignored. # !includedir /etc/mysql/conf.d/&amp;lt;/pre&amp;gt; Performance can be tweaked a bit once we&amp;rsquo;ve had the WordPress site up and running for 24-48 hours by using mysqltuner.pl. For good measure restart the service.
sudo service mysql restart
This concludes part 2 of the guide &amp;ldquo;MariaDB Setup for Ubuntu 14.04 - Make WordPress Fly&amp;rdquo;. As the rest of the guide is released links will be posted here and on all of the articles in the tutorial.
]]></content:encoded></item><item><title>HHVM, MariaDB and Nginx Make WordPress Fly - Intro</title><link>https://bryanapperson.com/blog/hhvm-mariadb-and-nginx-make-wordpress-fly-intro/</link><pubDate>Mon, 17 Feb 2020 20:17:30 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/hhvm-mariadb-and-nginx-make-wordpress-fly-intro/</guid><description>HHVM, MariaDB and Nginx Make WordPress fly (seriously). This site is running on what may the fastest possible software stack for WordPress. That stack is HHVM, MariaDB 10.1, Nginx and Ubuntu 14.04. As you are browsing this site you may notice that it is graphically intensive. It also leverages many CPU hungry plugins that would make it take 6-10 seconds to load on even good shared hosting. With this aforementioned software stack pages up to 5MB on this site still load in under a second, end-user pipe permitting.</description><content:encoded><![CDATA[HHVM, MariaDB and Nginx Make WordPress fly (seriously). This site is running on what may the fastest possible software stack for WordPress. That stack is HHVM, MariaDB 10.1, Nginx and Ubuntu 14.04. As you are browsing this site you may notice that it is graphically intensive. It also leverages many CPU hungry plugins that would make it take 6-10 seconds to load on even good shared hosting. With this aforementioned software stack pages up to 5MB on this site still load in under a second, end-user pipe permitting. This is all happening on a VPS with 2 x 2.26Ghz cores and 2GB of RAM. Not only that but this stack can serve over 1000 2MB WordPress pages per second without losing stability:
AB BenchMark [user@host ~]# ab -c 50 -n 5000 http://bryanapperson.com/ This is ApacheBench, Version 2.3 &amp;lt;$Revision: 655654 $&amp;gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking bryanapperson.com (be patient) Completed 500 requests Completed 1000 requests Completed 1500 requests Completed 2000 requests Completed 2500 requests Completed 3000 requests Completed 3500 requests Completed 4000 requests Completed 4500 requests Completed 5000 requests Finished 5000 requests Server Software: nginx Server Hostname: bryanapperson.com Server Port: 80 Document Path: / Document Length: 16138 bytes Concurrency Level: 50 Time taken for tests: 3.916 seconds Complete requests: 5000 Failed requests: 0 Write errors: 0 Total transferred: 83046606 bytes HTML transferred: 80706138 bytes Requests per second: 1276.68 \[#/sec\](mean) Time per request: 39.164 \[ms\](mean) Time per request: 0.783 \[ms\] (mean, across all concurrent requests) Transfer rate: 20707.77 \[Kbytes/sec\] received Connection Times (ms) min mean\[&#43;/-sd\] median max Connect: 1 1 0.2 1 5 Processing: 12 38 8.1 37 88 Waiting: 11 37 8.1 36 87 Total: 14 39 8.1 38 89 Percentage of the requests served within a certain time (ms) 50% 38 66% 41 75% 43 80% 44 90% 49 95% 54 98% 60 99% 66 100% 89 (longest request) Why HHVM for WordPress? So you may be asking yourself, is that really possible? Yes, HHVM and WordPress work very well together. If you asked me a few days ago I might have said no. But after playing around with HHVM, also known as &amp;ldquo;Hip Hop for PHP&amp;rdquo;, it is. HHVM is Facebook&amp;rsquo;s production PHP server which has now gone open source. At this point it still has a few compatibility issues. Especially with the usual culprits like Ioncube. However it works very well with WordPress 3.9&#43;. When combined with Nginx, MariaDB and Ubuntu &amp;ldquo;Trust Tahr&amp;rdquo; you get a pretty unbeatable platform for WordPress. Serving 200 request per second even on un-cached and heavy pages where PHP-FPM can only achieve 18 requests per second on a VM with the same resources (rendering the same un-cached pages).
MariaDB 10.1 MariaDB provides a solid database back-end and can easily be scaled out into a Galera Cluster for larger deployments. MariaDB 10.1 outperforms MySQL 5.7.4 by a significant margin, that is why it was chosen for this stack and it proved itself in implementation. MariaDB would perform better on SSD if available, but the above results were achieved on RAID10 7200RPM SATAIII with an LSI Megaraid BBU controller (512MB Cache).
Nginx Nginx can be somewhat less intuitive to configure then Apache. However it is a beast for serving static files especially per resource usage when configured correctly. Which is mostly what it does in this stack as all PHP processing is done by HHVM. Nginx really shines in serving static files to many user concurrently with the configuration we&amp;rsquo;ll outline in the coming articles.
Ubuntu 14.04 &amp;ldquo;Trusty Tahr&amp;rdquo; Choosing Ubuntu 14.04 for this deployment made sense, because it is LTS (5 years of support) and apt-get makes it almost trivial to get all of this setup. Not to mention that Ubuntu is a stable OS (although I usually prefer CentOS/RHEL). Nginx is built into the native repos for Ubuntu 14.04 and having maintained repos for both HHVM and MariaDB with Ubuntu 14.04 makes this stack easy to update later on. If you need an Ubuntu VPS you can get one for here. Before you get started with this you will probably want to secure your Ubuntu VPS.
WordPress 3.9.2 This series of articles will show you how to set all of this up and make it work with both a WordPress multi-site network, and a single WordPress site. I used the multi-site network with WP MU Domain Mapper and Nginx helper for ease of moving my multiple blogs and family/friends WordPress sites on to one platform. We will also be leveraging W3 Total Cache and APC (which is built in to HHVM) for Opcode caching.
Concluding the Introduction This setup is so efficient you wouldn&amp;rsquo;t need to scale out past a single VM instance unless you were in the Alexa top 10000, so we won&amp;rsquo;t handle that in this series. In articles to follow I will layout how to build this stack and use it for Lightning fast WordPress hosting on a shoestring budget. You&amp;rsquo;ll be able to handle 50,000 page loads an hour or more on a 2GB RAM Xen VM. I will update this article with links to the upcoming tutorials.
]]></content:encoded></item><item><title>From WordPress to Hugo</title><link>https://bryanapperson.com/blog/from-wordpress-to-hugo/</link><pubDate>Mon, 17 Feb 2020 00:00:00 UT</pubDate><dc:creator>Bryan Apperson</dc:creator><guid>https://bryanapperson.com/blog/from-wordpress-to-hugo/</guid><description>Hugo static blogs are awesome Migrating to Hugo It is 2019, enter the brave new world of serverless computing and static blogging. After years of using WordPress, and a few years without any updates this blog is in need of a refresh. When I originally created this blog I had servers (a whole web hosting company in fact). Now I just want to be able to create content and have a lightning fast website that is easy to maintain.</description><content:encoded><![CDATA[    Hugo static blogs are awesome    Migrating to Hugo It is 2019, enter the brave new world of serverless computing and static blogging. After years of using WordPress, and a few years without any updates this blog is in need of a refresh. When I originally created this blog I had servers (a whole web hosting company in fact). Now I just want to be able to create content and have a lightning fast website that is easy to maintain.
Earlier today I was doing some research, came across Hugo and decided to rebuild this blog using it and host it using github pages, at least initially. This site will likely be a work in progress for some time, however at least the text of the old content is migrated now. As I do this migration I will put out a series of articles on the how and the why of the migration.
Why Hugo and the Coder theme? Hugo is lightning fast at rendering pages and simple to use, plus the workflow with github pages is straightforward. The coder theme was chosed for now because I like the aesthetics.
Migrating from Wordpress I wanted a pretty fresh start, so I just used WordPress to export XML and then found a script here. Then I modified it for python 3 as follows:
#!/usr/bin/env python3 &amp;#34;&amp;#34;&amp;#34; This script is used to convert a WordPress XML dump to Hugo-formatted posts. NOTE: The WP post data is kept as-is (probably HTML). It is not converted to Markdown. This is to reduce the amount of &amp;#34;fixing&amp;#34; one has to do after the data is converted (e.g. line endings, links, etc). This is generally not an issue since Markdown allows HTML. The post Metadata is converted to TOML. The posts are written as: &amp;lt;year&amp;gt;/&amp;lt;title&amp;gt;.md where &amp;lt;year&amp;gt; is the year the post was written, and &amp;lt;title&amp;gt; is the WP title with all non-word characters replaced with &amp;#34;-&amp;#34;, and converted to lower case. &amp;#34;&amp;#34;&amp;#34; # Imports ###################################################################### import os import re import maya import time import calendar import xml.etree.ElementTree as ET from distutils.version import LooseVersion # Metadata ##################################################################### __author__ = &amp;#34;Timothy McFadden&amp;#34; __creationDate__ = &amp;#34;07/24/2015&amp;#34; __license__ = &amp;#34;MIT&amp;#34; __version__ = &amp;#34;1.0.0dev&amp;#34; # Globals ###################################################################### DEBUG = False KNOWN_WP_VERSION = LooseVersion(&amp;#34;4.2&amp;#34;) def hugo_format(data): result = [&amp;#34;&#43;&#43;&#43;&amp;#34;] for heading in [&amp;#34;title&amp;#34;, &amp;#34;date&amp;#34;, &amp;#34;type&amp;#34;]: result.append(&amp;#39;%s= &amp;#34;%s&amp;#34;&amp;#39; % (heading, data[heading])) result.append(&amp;#34;tags = %s&amp;#34; % str(data[&amp;#34;tags&amp;#34;])) result.append(&amp;#34;&#43;&#43;&#43;&amp;#34;) result.append(&amp;#34;&amp;#34;) result.append(data[&amp;#34;body&amp;#34;]) return &amp;#34;\n&amp;#34;.join(result) def wp_version_check(channel): match = re.search(&amp;#34;\?v=([\d\.]&#43;)&amp;#34;, channel.find(&amp;#34;generator&amp;#34;).text) if not match: print(&amp;#34;WARNING: Could not find WP version in your XML.&amp;#34;) print(&amp;#34;...This script may not work&amp;#34;) raw_input(&amp;#34;...press Enter to continue: &amp;#34;) else: wp_version = LooseVersion(match.group(1)) if wp_version &amp;lt; KNOWN_WP_VERSION: print(&amp;#34;WARNING: WP version in your XML (%s) is less than known good version (%s)!&amp;#34; % (wp_version, KNOWN_WP_VERSION)) print(&amp;#34;...This script may not work&amp;#34;) raw_input(&amp;#34;...press Enter to continue: &amp;#34;) def convert_wp_xml(xml_path): tree = ET.parse(xml_path) # FYI: xml.etree doesn&amp;#39;t support reading the namespaces, and I don&amp;#39;t feel # like requiring lxml. nsmap = { &amp;#34;excerpt&amp;#34;: &amp;#34;http://wordpress.org/export/1.2/excerpt/&amp;#34;, &amp;#34;content&amp;#34;: &amp;#34;http://purl.org/rss/1.0/modules/content/&amp;#34;, &amp;#34;wfw&amp;#34;: &amp;#34;http://wellformedweb.org/CommentAPI/&amp;#34;, &amp;#34;dc&amp;#34;: &amp;#34;http://purl.org/dc/elements/1.1/&amp;#34;, &amp;#34;wp&amp;#34;: &amp;#34;http://wordpress.org/export/1.2/&amp;#34;, } channel = tree.find(&amp;#34;channel&amp;#34;) wp_version_check(channel) for item in channel.findall(&amp;#34;item&amp;#34;): data = { &amp;#34;tags&amp;#34;: [], &amp;#34;title&amp;#34;: (item.find(&amp;#34;title&amp;#34;).text).strip(&amp;#39;\n&amp;#39;), &amp;#34;date&amp;#34;: None, &amp;#34;body&amp;#34;: None, &amp;#34;fpath&amp;#34;: None, &amp;#34;type&amp;#34;: &amp;#34;post&amp;#34; } scraped_time = item.find(&amp;#34;pubDate&amp;#34;).text datetime = maya.parse(scraped_time).datetime(to_timezone=&amp;#39;US/Eastern&amp;#39;, naive=True) data[&amp;#34;date&amp;#34;] = datetime data[&amp;#34;tags&amp;#34;] = [x.attrib[&amp;#34;nicename&amp;#34;] for x in item.findall(&amp;#34;category&amp;#34;)] data[&amp;#34;body&amp;#34;] = item.find(&amp;#34;content:encoded&amp;#34;, nsmap).text fname = re.sub(&amp;#34;\W&#43;&amp;#34;, &amp;#34;-&amp;#34;, data[&amp;#34;title&amp;#34;]) fname = re.sub(&amp;#34;(-&#43;)$&amp;#34;, &amp;#34;&amp;#34;, fname) fname = fname[1:] data[&amp;#34;fname&amp;#34;] = &amp;#34;{}.md&amp;#34;.format(fname.lower()) data[&amp;#34;fdir&amp;#34;] = os.path.abspath(os.path.join(&amp;#34;.&amp;#34;, str(datetime.year))) data[&amp;#34;fpath&amp;#34;] = os.path.join(data[&amp;#34;fdir&amp;#34;], data[&amp;#34;fname&amp;#34;]) hugo_text = hugo_format(data) if not os.path.isdir(data[&amp;#34;fdir&amp;#34;]): os.makedirs(data[&amp;#34;fdir&amp;#34;]) with open(data[&amp;#34;fpath&amp;#34;], &amp;#34;wb&amp;#34;) as fh: fh.write(hugo_text.encode(&amp;#39;UTF-8&amp;#39;)) print(&amp;#34;Created: {}/{}&amp;#34;.format(datetime.year, data[&amp;#34;fname&amp;#34;])) if __name__ == &amp;#39;__main__&amp;#39;: import sys if len(sys.argv) == 1: print(&amp;#34;Usage: python wp_to_hugo.py &amp;lt;wordpress XML file&amp;gt;&amp;#34;) sys.exit(1) convert_wp_xml(sys.argv[1]) I still need to manually sift through and fix images and curate the older posts have now updated all of the older posts.
Github Pages I chose github pages because I already have a github account and the workflow seemed good. Plus there is an easy way I plan to automate publishing master using travis-ci in the near future have automated publishing. I followed the Hugo docs, using the gh-pages branch based workflow. The repo for this blog now lives here.
Travis CI I adapted this guide on Travis CI and Hugo to automate the build and publish of my blog to github pages. It is pretty straightforward and I highly recommend it.
Here is the .travis.yml that I ended up with after optimizing a bit for faster builds of Hugo:
# Credit to:#https://axdlog.com/2018/using-hugo-and-travis-ci-to-deploy-blog-to-github-pages-automatically/# https://docs.travis-ci.com/user/deployment/pages/# https://docs.travis-ci.com/user/reference/xenial/# https://docs.travis-ci.com/user/languages/go/# https://docs.travis-ci.com/user/customizing-the-build/cache:directories:- $HOME/.cache/go-build- $HOME/gopath/pkg/moddist:xeniallanguage:gogo:- 1.12.x# Only clone the most recent commit.git:depth:1# before_install# install - install any dependencies requiredinstall:- go get github.com/gohugoio/hugobefore_script:- rm -rf public 2&amp;gt; /dev/null# script - run the build scriptscript:- hugodeploy:provider:pagesskip-cleanup:truegithub-token:$GITHUB_TOKEN# Set in travis-ci.org dashboard, marked secureemail:$GITHUB_EMAILname:$GITHUB_USERNAMEverbose:truelocal-dir:publicfqdn:bryanapperson.comon:branch:master# branch contains Hugo generator codeConclusion Overall the initial learning curve, setup, customization and migration took about 8 hours. I would say that is pretty good. There will definitely be more posts to follow on my journey with blogging using Hugo.
]]></content:encoded></item></channel></rss>